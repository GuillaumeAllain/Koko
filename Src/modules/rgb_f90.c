////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2020 The Koko Project Developers
//
// See the file COPYRIGHT.md in the top-level directory of this
// distribution
//
// This file is part of Koko.
//
// Koko is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Koko is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Koko; see the file COPYING.  If not, see
// <https://www.gnu.org/licenses/>.
//
////////////////////////////////////////////////////////////////////////

// Provides functions for RGB color value lookup
//
// Ulf GRIESMANN, June 2020

#include <stdio.h>
#include <string.h>

#include "rgb_hash.h" // hash table for color lookup

#define COLSTRLEN 32  // max. color string length


//--- Prototypes ---------------------------------------------------------

void c_rgbval( const char *colorname, int lcn, int *R, int *G, int *B );
void c_rgbhex( const char *colorname, int lcn, char *hexstring, int lhs );
static void lookup_rgb( const char *colorname, int *R, int *G, int *B );


//------------------------------------------------------------------------

// F90 - callable
// For a specified color name, returns a triplet of
// RGB (red - green - blue) values in the range 0 .. 255.
// If the color lookup fails, the returned values are negative.
//
// INPUT
// colorname :  a color name (camelHump format, no spaces)
// lcn :        number of characters in Fortran colorname string
//
// OUTPUT
// R,G,B :      red green blue values corresponding to the color
void
c_rgbval( const char *colorname, int lcn, int *R, int *G, int *B )
{
   char loc_colorname[COLSTRLEN];
   int nc, r, g, b;

   // make sure we don't write outside the local buffer
   if (lcn > COLSTRLEN - 1) {
      nc = COLSTRLEN - 1;
   }
   else {
      nc = lcn;
   }
   
   // turn color name into a C string
   strncpy(loc_colorname, colorname, nc);
   loc_colorname[nc] = '\0';   // in case someone messes up the color name

   // look up keyword - color triplet structure
   lookup_rgb(loc_colorname, &r, &g, &b);

   // return results
   *R = r;
   *G = g;
   *B = b;
}


// F90 - callable
// For a specified color name, returns a triplet of
// RGB (red - green - blue) values in the form of a
// hex format string: #RRGGBB
// If the color lookup fails, the first character in the
// return string will be 'F'
//
// INPUT
// colorname :  a color name (camelHump format, no spaces)
// lcn :        number of characters in Fortran colorname string
//
// OUTPUT
// hexstring :  RGB color coded as hexadecimal string
// lhs :        length of the Fortran string variable
void
c_rgbhex( const char *colorname, int lcn, char *hexstring, int lhs )
{
   char loc_colorname[COLSTRLEN];
   int nc, r, g, b;

   // make sure we don't write outside the local buffer
   if (lcn > COLSTRLEN - 1) {
      nc = COLSTRLEN - 1;
   }
   else {
      nc = lcn;
   }
   
   // turn color name into a C string
   strncpy(loc_colorname, colorname, nc);
   loc_colorname[nc] = '\0';   // in case someone messes up the color name

   // look up keyword - color triplet structure
   lookup_rgb(loc_colorname, &r, &g, &b);

   // return Fortran string with hex-coded rgb values
   if (lhs < 8) {              // output string is too short
      hexstring[0] = 'F';
      memset(hexstring+1, ' ', lhs-1);
   }
   else {
     sprintf(hexstring, "#%2X%2X%2X", r, g, b);
     memset(hexstring+7, ' ', lhs-7);
   }
}


// Function that performs the rgb value lookup using a hash function
// generated by gperf
static void
lookup_rgb( const char *colorname, int *R, int *G, int *B )
{
   struct keyword *pk;   // pointer to keyword structure
   pk = (struct keyword *)in_word_set(colorname, strlen(colorname));

   if (pk == NULL) {
     *R = -1;
     *G = -1;
     *B = -1;
   }
   else {
     *R = pk->rgb[0];
     *G = pk->rgb[1];
     *B = pk->rgb[2];
   }
}
